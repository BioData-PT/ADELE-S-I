#!/bin/sh

set -u -e -x

myself=$0

# Default values for global options.
sda_config=s3cmd.conf		# --sda-config pathname
sda_key=crypt4gh_key.pub	# --sda-key pathname

# Other variables.
mq_host=localhost
mq_credentials=test:test

url_api=http://$mq_host:15672/api
url_exchanges=$url_api/exchanges/gdi/sda
url_queues=$url_api/queues/gdi

encrypt () {
	for pathname do
		shift
		case $pathname in
			*.c4gh)
				# Don't encrypt.
				;;
			*)
				# Encrypt if there's no encrypted
				# variant of the file.
				[ ! -f "$pathname.c4gh" ] && set -- "$@" "$pathname"
		esac
	done

	if [ "$#" -gt 0 ]; then
		sda-cli encrypt -key "$sda_key" "$@"
	fi
}

upload () {
	# Encrypt+upload using sda-cli.

	encrypt "$@"

	for pathname do
		shift
		pathname=${pathname%.c4gh}.c4gh
		set -- "$@" "$pathname"
	done

	sda-cli upload -config "$sda_config" "$@"
}

curl () {
	# Helper function that makes curl calls a bit shorter.
	command curl --silent \
		--request POST \
		--user "$mq_credentials" \
		--header "Content-Type: application/json" \
		"$@"
}

publish () {
	# Will read base64-encoded messages from standard input, one per
	# line, decode each message and publish it.

	while IFS= read -r message; do
		printf "%s\n" "$message" | base64 -d |
		curl --data @- "$url_exchanges/publish"
	done
}

ingest () {
	# Ingest named files.

	access_key=$(
		sed	-e '/^access_key[[:blank:]]*=[[:blank:]]*/!d' \
			-e 's///' -e 's/[[:blank:]]*$//' -e 'q' \
			"$sda_config"
	)

	# If no arguments are given, list the files that may be
	# ingested, then return immediately.
	if [ "$#" -eq 0 ]; then
		curl --data \
			'{"count":-1,"encoding":"base64","ackmode":"ack_requeue_true"}' \
			"$url_queues/inbox/get" |
		jq -r --arg access_key "$access_key" '
			unique_by(.properties.correlation_id)[] |
			.payload | @base64d | fromjson |
			select(.filepath | startswith($access_key + "/")).filepath |
			sub(".*?/"; "")'
		return
	fi

	for pathname do
		shift
		pathname=$access_key/$(basename "$pathname" .c4gh).c4gh
		set -- "$@" "$pathname"
	done

	tmpdir=$(mktemp -d)
	# shellcheck disable=SC2064
	trap "cd /; rm -r '$tmpdir'" EXIT
	cd "$tmpdir" || exit

	# Get upload messages and ACK them all without requeuing them.
	# This empties the inbox queue.
	curl --data '{"count":-1,"encoding":"base64","ackmode":"ack_requeue_false"}' \
		"$url_queues/inbox/get" >uploaded.json

	# Requeue the messages that we're not interested in.
	#
	# We do this by base64-encoding each message that we need to
	# requeue.  The base64 encoding is done by jq.  Then we pass the
	# stream of encoded messages to our a helper function, which
	# decodes and publish them.  The temporary base64 encoding is
	# only a way of converting each message into a single line of
	# text that can be safely handled by the shell.
	#
	# Note that we only requeue unique messages, based on their
	# correlation ID.
	#
	jq -r 'JOIN(INDEX($ARGS.positional | unique[]; .);
		unique_by(.properties.correlation_id)[];
		.payload | @base64d | fromjson.filepath;
		if .[1] then empty else .[0] | @base64 end)' \
		--args "$@" <uploaded.json | publish

	# Filter out (extract) the ones that we want to ingest.  We
	# get a set of JSON objects.  This set does not contain any
	# duplicated correlation IDs.
	#
	# Then convert the extracted messages into ingestion messages
	# and publish these.
	#
	jq 'JOIN(INDEX($ARGS.positional | unique[]; .);
		unique_by(.properties.correlation_id)[];
		.payload | @base64d | fromjson.filepath;
		if .[1] then .[0] else empty end) |
		.payload |= (
			@base64d | fromjson |
			.type = "ingest" | del(.filesize,.operation) |
			tojson | @base64
		) |
		.routing_key = "ingest" | del(.payload_bytes) | @base64' \
		--args "$@" <uploaded.json | publish
}

accession () {
	:
}

dataset () {
	:
}

usage () {
	case ${1-} in
		upload|ingest|accession|dataset)
			"usage_$1"
			;;
		"")
			usage_general
			;;
		*)
			usage_general
			return 1
	esac
}

usage_general () {
cat <<-USAGE_GENERAL
	General synopsis:
	    $myself [GLOBAL OPTIONS] [help] {upload|ingest|accession|dataset} [ARGUMENTS]

	Global options:
	    --sda-config pathname	SDA S3 configuration file	Default: $sda_config
	    --sda-key pathname		SDA CRYPT4GH public key file	Default: $sda_key

	Specific synopsis:
	    $myself help

	    $myself [...] upload pathname [pathname...]
	    $myself help upload

	    $myself [...] ingest [ pathname [pathname...] ]
	    $myself help ingest

	    $myself [...] accession pathname accessionID
	    $myself [...] accession pathname
	    $myself [...] accession
	    $myself help accession

	    $myself [...] dataset [--add] datasetID accessionID [accessionID...]
	    $myself [...] dataset [--add] datasetID pathname [pathname...]
	    $myself [...] dataset datasetID
	    $myself help dataset

	USAGE_GENERAL
}

# Handle global options.
while true; do
	case ${1-} in
		--sda-config)
			sda_config=$2
			;;
		--sda-key)
			sda_key=$2
			;;
		*)
			break
	esac
	shift 2
done

# Handle sub-comands.
case ${1-} in
	upload|ingest|accession|dataset)
		"$@"
		;;
	help)
		shift
		usage "$@"
		;;
	*)
		usage
		exit 1
esac
